(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{581:function(a,n,s){"use strict";s.r(n);var e=s(5),t=Object(e.a)({},(function(){var a=this,n=a.$createElement,s=a._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"关于patch-package的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于patch-package的使用"}},[a._v("#")]),a._v(" 关于patch-package的使用")]),a._v(" "),s("p",[a._v("在某些情景下我们需要修改node包中的源码来更加适应自己的需求，让作者添加肯定不太现实，patch-package就是最佳解决方案，我们不可能去修改node包，协作开发你npm i 下来的还是云端的又不是你修改过的源码，你也不太可能将node包放在git上，太过于庞大了也不利于维护，patch-package类似于打补丁，你修改源码后它会利用diff算法，算出差异，在目录下生成patches文件夹，这个就是补丁，其实这个文件夹的意义就是你每次npm/yarn i的时候它都会注入补丁，间接修改node包，具体使用方法如下:")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('# 下载patch-package\nyarn install patch-package\n# package.json 添加钩子\n  "scripts": {\n    "postinstall": "patch-package"\n  },\n# 修改node包后使用命令\nyarn patch-package vuepress-theme-reco\nyarn patch-package node包名\n# 然后你就可以删除node 再yarn install 测试了\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("p",[a._v("有一个小坑就是你如果修改了style中的图片，注入补丁后图片是无法被转码的都是损坏的，后来我干脆直接用了服务器上的图片地址。")])])}),[],!1,null,null,null);n.default=t.exports}}]);