---
title: 前端面试题精选(更新中)
date: 2021-3-15
tags:
 - vue
categories:
 -  面试题
---

## HTML

```
一.BFC的概念？ 规范是什么？ 生成？作用？
1.bfc全称Block formatting context，块级格式化上下文，字面理解就是一个独立渲染的区域，里面的内容不受外界的影响。
2.一般设置了浮动，绝对定位/固定定位、dispaly的值为inline-block、table-cell、flex…或者元素设置了overflow的值除visible的情况下会产生。
3.一般用于清除浮动、设置左边固定大小，右边自适应布局，margin之间的层叠问题

二.谈谈你对重构的理解
在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为，也就是在不改变ui的情况下，对网站进行优化
表格布局改为DIV+CSS
兼容各种现代浏览器
对移动端的体验优化
优化SEO
减少代码耦合
代码弹性
遵守统一的代码规范
设计可扩展的API
对一些支持不太好旧框架进行代替
压缩 js,css,image
采用cdn（内容分发网络）来加速资源加载
减少js对于dom的操作
HTTP服务器的文件缓存

三.谈谈性能优化问题
使用精灵图减少加载时间
尽量使用字体图标，少用图片
避免多余使用选择器
样式不要重复，增加复用性
尽量减少重排和重绘，会消耗dom性能

四.常见浏览器内核
Safari:webkit
chrome:Chromium
Opera:blink
IE:Trident
firefox:Gecko

五.css盒子
边框盒子和内容盒子
ie浏览器默认是边框盒子，也是现在常用的，因为布局是子元素相对父元素布局，有固定大小的子元素设置布局
更为方便，它的高度就是盒子的大小，里面的内容需要自己计算
chromr浏览器默认是内容盒子，它的高度是内容的高度，盒子大小需要自己计算
```

## js

```
一.哪些操作会造成内存泄漏
内存泄漏指不用拥有或需要任何对象（数据）之后，它们仍然存在于内存中。
提示：垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的唯一引用是循环的，那么该对象占用的内存立即被回收。
如果setTimeout的第一个参数使用字符串而非函数，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留是，就会产生一个循环）等会造成内存泄漏。

二.谈谈你对闭包的理解
在一个函数内定义一个内部函数，并将内部函数返回，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包（或者将内部函数成为闭包）。
也有些人定义闭包的概念为：在一个函数内部定义一个函数，那么这个内部函数就被称为“闭包”。
通过闭包，外部环境可以访问到函数里的变量
使用闭包，内部函数变量不会污染外部变量，规避冲突，变量私有化
闭包的副作用:
变量常驻内存，造成内存溢出，所以在不使用时，记得清空。
正常情况下，f1函数的变量在f1()执行完成退出当前执行环境时，会被垃圾回收收回。但是由于f2引用了它，而f2又赋值给了result变量，会标记f2被引用了一次，所以f2会在内存里（这里是正常的），f1中变量由于存在于f2函数的closure对象里（闭包里变量的集合）。
f2一直存在内存中，那么f2中的闭包变量也就会一直存在内存中，这些变量造成了内存溢出。
这里涉及到js垃圾回收机制，要想很好理解，可以去看看关于垃圾回收机制的问题。
解决方案：在不用时记得即使清空变量。

三.谈谈你对作用域以及作用域链的理解（顺便补充执行上下文，执行上下文栈）
首先理解一下层级关系 在运行代码前会产生【准备工作】，就是创建执行上下文，执行上下文存在【作用域链】，变量对象AO/GO、this指向，所以我们知道了作用域链是在执行上下文产生后，函数运行前产生的，先不管作用域链，我们回到执行上下文，执行上下文首先会遇到全局创建全局执行上下文，然后遇到可以执行的函数，会对应产生对应的AO，由此可见有这么多执行上下文，为了便于管理，诞生了【执行上下文栈】这个概念。
当全局上下文创建的时候就已经被压到了栈底，然后全局上下文进行初始化（确定了scope，绑定了this，完成变量声明函数声明并进行提升），当执行一个函数的时候，创建函数的执行上下文，函数执行完毕后，会从栈中弹出，遵循栈【先进后出】，所以全局执行上下文永远在最后才弹出，也就是关闭浏览器的时候
js采用的词法作用域（静态的作用域），所以在代码执行前就已经确定了，可以认为执行执行上下文是动态的 ，作用域是静态的。作用域分为两种：全局作用域和局部作用域，规定了变量的可访问范围
函数在创建的时候会产生一个内部属性[[scope]]，这个属性就是一个作用域链，但不是完整的，当函数产生了执行上下文，这时候获取它对应的活动对象AO/GO，将这个活动对象放入到作用域的前端，根据执行上下文的理解，第一个遇到全局执行上下文中的活动对象GO，肯定是第一个被放入scope的，那么寻找变量也是一层一层找的，从当前AO一直找父元素的AO到GO为止。
暂时写这么多，其他的会继续补充，可能会存在理解错误望改正

四.DOM操作——怎样添加、移除、移动、复制、创建和查找节点
(1)创建新节点
　　createDocumentFragment() //创建一个DOM片段
　　createElement() //创建一个具体的元素
　　createTextNode() //创建一个文本节点
(2) 添加、移除、替换、插入
　　appendChild()
　　removeChild()
　　redplaceChild()
　　insertBefore() //在已有的子节点前插入一个新的子节点
(3) 查找
　　getElementsByTagName() //通过标签名称
　　getElementsByName() //通过元素的Name属性的值(IE容错能力较强会得到一个数组，其中包括id等于name值的)
　　getElementById() //通过元素Id，唯一性

五.cookies sesssionstorage loacalstorage的区别
cookie是在HTML4中使用的给客户端保存数据的，也可以和session配合实现跟踪浏览器用户身份；而webstorage（包括：localStorage和sessionStorage）是在HTML5提出来的，纯粹为了保存数据，不会与服务器端通信。WebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。
 相同点：
  cookie，localStorage，sessionStorage都是在客户端保存数据的，存储数据的类型：都是字符串。
 不同点：
 1、生命周期：
 1）、cookie如果不设置有效期，那么就是临时存储（存储在内存中），是会话级别的，会话结束后，cookie也就失效了，如果设置了有效期，那么cookie存储在硬盘里，有效期到了，就自动消失了。
 2）、localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。
 3）、sessionStorage仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。
  可以简单的理解为：sessionStorage，没有设置有效期的cookie。
  如果说把cookie的有效期设置为永远永远，永久，那么就是localStorage。
  cookie没有设置有效期，那么就是sessionStorage
 2、网络流量：cookie的数据每次都会发给服务器端，而localstorage和sessionStorage不会与服务器端通信，纯粹为了保存数据，所以，webstorage更加节约网络流量。
 3、大小限制：cookie大小限制在4KB，非常小；localstorage和sessionStorage在5M
 4、安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获。
 5、使用方便性上：WebStorage提供了一些方法，数据操作比cookie方便；
            setItem (key, value) ——  保存数据，以键值对的方式储存信息。
       　　   getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
         　　 removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
         　 　clear () ——  删除所有的数据
         　　 key (index) —— 获取某个索引的key

六.js如何实现继承
方法一：借助构造函数实现继承
方法二：借助原型链实现继承
方法三，class继承

七.谈谈你对ajax的理解
Ajax 是一种创建交互式网页应用的的网页开发技术；Asynchronous JavaScript and XML”的缩写。Ajax 的优势：通过异步模式，提升了用户体验。优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用。
优点:可以实现局部刷新，在不更新整个页面的前提下维护数据，提升用户体验度。
```

## VUE

```
一.请你简述生命周期
一个事物从诞生到消亡，vue的生命周期就是 vue从创建到销毁之间的各种事件
也可以说是生命周期钩子
创建时候的生命周期函数=》运行期间的生命周期函数=》销毁期间的生命周期函数
首先vue在new之后会先初始化事件和生命周期函数，然后遇到第一个生命周期函数beforeCreate，意味着示例创建完毕，但是这个时候data和methods都没有被初始化
遇到的第二个生命周期函数是created，这时候data和methods都被初始化了，如果要调用方法或数据，最早只能在这里
接下来vue开始进行模板的编译，在内存中生成编译好的模板，但还没有挂载到页面，这是第三个生命周期函数beforeMount
最后将内存中的模板渲染到了页面中，这时候是mounted生命周期，组件被完全创建，进入运行阶段
当数据发生改变时，先遇到beforUpdata生命周期函数，这时候页面中的数据还没更新；然后dom重新渲染到页面，下面的updataed生命周期中内容就已经重新渲染完毕了
执行beforeDestroy钩子函数时，vue示例已经进入销毁阶段，但还没真正销毁
执行到destroyed函数就被真正销毁了
 

二.
```