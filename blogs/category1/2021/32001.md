---
title: css+js常见面试题
date: 2021-3-20
tags:
 - js
 - css
categories:
 -  面试题
---

```
### css简答题

1 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？

html元素本质上是一个盒子，盒模型是浏览器用于描述盒子的标准

盒子模型包括 外边距，边框，内边距，内容

ie低版本使用的是border-box 边框盒子：内容是边框+内容+内边距 是我们一般开发使用的盒子模型，方便布局

现在默认的是content-box 内容盒子：内容不包括边框和内边距

2 box-sizing属性？

设置盒子模型border-box/content-box

3 CSS选择器有哪些？哪些属性可以继承？

css选择器的作用是选中html元素，设置css属性

元素选择器、id选择器、class选择器、父级选择器、伪类选择器

字体样式一般都可以继承，设置浮动定位之类的不可以继承

4 CSS优先级算法如何计算？

两个层面

行内样式优先级最高 然后是style内的样式，最后是引入的样式

!important>id选择器>class选择器>元素选择器

可以利用选择器优先级方式，解决样式冲突问题

尽量少使用!important,尽量合理使用css代替!important

5 CSS3新增伪类有那些?

:hover :checked 还有ntr-type之类的选择器

6 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？

对于有长度的div可以使用margin 0 auto 再设置行高=高度

或父元素设置弹性布局，水平居中属性

或者父元素设置相对定位4个位置为0 +magin:auto

浮动元素可以在外面设置一个块，让这个块居中，或使用margin

绝对定位的div可以通过left/right/top/bottom 调整

7 display有哪些值？说明他们的作用?

flex :开启弹性布局

inline-block 设置成行内块元素 继承行元素和块元素所有特点 可以设置宽高，是一个块不会换行

none:设置元素隐藏且不保留位置

inline：设置成行元素

block :设置成块元素 

8 position的值？

relative:相对定位：适用于小范围的移动，根据的原来的位置移动，也可以和绝对定位配合实现子绝父相

absolute:绝对定位：适用于比较大范围的移动，根据的是设置了relative的父级元素移动

fixed：固定定位：适用于侧边广告，底部tab栏的布局，一般随着body可视区域的移动而移动

9 CSS3有哪些新特性？

盒子阴影

动画 过度

3d 2d

10 请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？

弹性布局适用于一些比较复杂的布局中，例如一个div中有很多子div，这些div又保持这一些相同的位置属性，或者与媒体查询结合，制作手机端的页面

弹性布局首先需要在父元素开启（display:flex）flex-direction:可以设置主轴是x还是y,父元素可以设置主轴的对齐方式 justify-content，其中包含水平居中，等差分开，或者两端顶格，中间等差等布局， align-items: 设置了主轴垂直轴的对齐方式，flow-grow 设置了div占据剩余空间的多少（放大）flow-shrink(缩放) 而且弹性布局还可以单独设置子项目的对齐方式，是一种非常灵活的布局方式

11 用纯CSS创建一个三角形的原理是什么？

设置一个有没有宽高的div 然后设置边框、边框颜色，将其他三个边框变成透明色就是三角形了

我所理解为div越来越小，边框就会越来越趋向于三角形，因为与div接触的面越来越小，边框的接触面也会越来愈小最后变成尖的了

12 一个满屏品字布局如何设计?

设置一个宽高占比100%的div 在里面加入<p>品</p> 可以通过定位或者弹性布局让它居中

13 常见的兼容性问题？

 一些谷歌支持的属性 低版本ie不支持 例如visibility：collapse 需要做兼容处理

{

background-color:#flee18; 所有识别

background-color:#00deff\9;IE6,7,8识别

background-color:#a200ff;IE6,7识别

_background

-a200ff IE6

color:#

}

14 为什么要初始化CSS样式

因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

15 absolute的containing block计算方式跟正常流有什么不同？

无论属于哪种，都要先找到其祖先postion值不为static的元素，然后再判断

若此元素位inline元素，则containing block 为能够包含这个元素生成的第一个和最后一个inline box的padding box（除margin border外的区域）的最小矩形

否则，别由这个祖先元素的padding box构成

如果都找不到则为initial containing block 

补充

 static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）
absolute: 向上找最近的定位为absolute/relative的元素
fixed: 它的containing block一律为根元素(html/body) 

16 CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？

visibility：collapse 是谷歌的隐藏但保留位置

在ie则不保留位置

17 display:none与visibility：hidden的区别？

display:none 隐藏但不保留位置

visibility：hidden隐藏保留位置 一般和动画效果配合

18 position跟display、overflow、float这些特性相互叠加后会怎么样？

display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。
类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。 

19 对BFC规范(块级格式化上下文：block formatting context)的理解？

BFC又称为块级格式化上下文，一般设置了绝对定位/固定定位，overflow：hidden

display:inline-block table-cell等会产生

bfc通常用于清除浮动 设置左边固定大小，右边自适应，或者消除盒子边框塌陷的问题

20 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？

设置float会产生浮动 浮动会对后面的元素产生影响，所以需要清除

一般设置父盒子高度可以解决 通常我们为需要清除的元素设置一个伪元素：after{content:'';clear:both;zoom:0}

21设置元素浮动后，该元素的display值是多少？

block

22 移动端的布局用过媒体查询吗？

@media 屏幕 and (条件) 是媒体查询的格式

我们一般设置一个布局，另一个端的布局就要使用媒体查询来完成

对于那些拥有只是样式相同，布局不同的布局，，我会使用媒体查询来完成移动端的布局

24 CSS优化、提高性能的方法有哪些？

尽量使用精灵图

避免后代选择器 链式选择符 !important

尽量少使用相对/决定定位 减少重排消耗dom性能

相同的样式写进一个css中，提高样式的复用性，减少样式的重复性

25 margin和padding分别适合什么场景使用？

margin我一般用于两个元素之间有空隙 padding我一般设置里面的元素距离父元素的间隙

26 浏览器是怎样解析CSS选择器的？

浏览器是从右至左解析的，因为如果从左至右解析，匹配不到，会产生回溯，消耗性能

从右至左解析，会一层一层向上寻找，一旦找到结束所有遍历

27 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？

我们用的比较多的响应式设计就是媒体查询 

可以用来做自己的栅格系统

一般我们确立一个端的设计，另一个端我们就用媒体查询来完成

对于那些拥有只是样式相同，布局不同的布局，，我会使用媒体查询来完成移动端的布局

28 你对line-height是如何理解的？

设置字体的行高，如果这个字体的行高和它父元素div的高度相同，或者这是span inline-block了 那么它就会垂直居中

29让页面里的字体变清晰，变细用CSS怎么做？

 -webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。 

30如果需要手动写动画，你认为最小时间间隔是多久，为什么？

多数显示器默认频率是60Hz，即1秒刷新60次，
所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms

31display:inline-block 什么时候会显示间隙？，如何解决呢？

并排会产生间隙

可以用margin负值移动

或者将标签写成一行

一般使用父元素font-size ：0

32有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度

    <div style="height: auto;">
        <div style="height: 100px;background-color: black;"></div>
        <div style="height: calc(100% - 100px);background-color: red;"></div>
    </div>// 高度自适应 一个高度100px 那就没有空间了 除非高度>100啊

33style标签写在body后与body前有什么区别？

 页面加载自上而下 当然是先加载样式。
写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） 

34阐述一下CSS Sprites

css精灵图，是将很多图片放入到一张图片中，这样减少了加载时间，也是一种性能优化方案

35png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？

 png:没有压缩，由于它的背景透明，一般用作小图标

jpg:会被压缩，一般用于界面上的展示

gif:会被压缩，由于gif是动态图，被用于有动态图需求的网站中

webp:是谷歌新出的图片格式，但是由于兼容性问题，用的比较少

### es5综合测试题


## es5综合测试

##### 请说出下面方法的作用是什么呢？

foreach

数组对象api 用于遍历 没有返回值

push

数组api 从数组尾部添加一个元素

toString

数组api 将数组转换成字符串

join

数组api 将数组转换为字符串 参数是string 将逗号切割成其他字符

arr.indexOf

数组api 查找数组中是否有相同元素 有返回下标 没有返回-1 参数是查找二点内容

arr.sort

数组api 用于数组的排序 

split

字符串的api 用于将字符串切割并返回数组 参数是被切割的内容

replace

字符串api 用于替换 参数一是正则表达式 参数二是替换成的内容

slice

数组api 第一个参数是开始索引 第二个参数是结束索引 截取之间的长度，返回值是被截取的子元素

substr

字符串api 第一个参数是开始索引，第二个参数是长度，截取从第一个下标开始到指定长度的字符，返回的是被截取的子元素

##### 完成下面要求

~~~js
    <script>
        var arr = [1, 2, 3, 4, 'dd']
        //1 将arr 数组变为字符串
        //2：将字符串颠倒
        //3：将字符串中 dd 替换为 FF
        var res = arr.join('')
        console.log(res);
        var str = ''
        for(var i =res.length-1;i>=0;i--){
            str+= res[i]
        }
        console.log(str);
        var result = str.replace(/dd/,'FF')
~~~

~~~
    <script>
    var arr = [1,1,1,1,2,2,2,3,3,3,3]
    // arr 数组去重
    function ways(array){
        return array.filter(function (index,item,array) {
            return array.indexOf(index)==item
        })
    }
    console.log(ways(arr));
    </script>
~~~

~~~js
    <script>
    var arr = [{name:'zc'}]
    // 实现深拷贝 ARR 
    function ways(arr) {
        if(!(arr instanceof Object))
        return arr
        if(Array.isArray(arr)){
            var arrcopy = []
            for(var x in arr){
                var str = ways(arr[x])
                arrcopy.push(str)
            }
            return arrcopy
        }
        var obj ={}
        for(var y in arr){
            obj[y] = ways(arr[y])
        }
        return obj
    }
    var result = ways(arr)
    arr[0].test = '测试'
    console.log(arr,result);
    </script>
~~~

~~~js
var str = 'abcdefghijklmnopqrstuvwxyz1234567890';
<script>
    var str = 'abcdefghijklmnopqrstuvwxyz1234567890'
    //随机输出6为的字符 
        var res = "";
        for (var i = 0; i < 6; i++) {
            var a =parseInt( Math.random()*str.length)
            res += str[a]
            console.log(res);
        }
        document.write(res)
    </script>
~~~

~~~js
    <script>
        var str = 'djfqweurqwe432423edfssdfsd';
        // 统计 d 字符再 str 中出现了多少次
        var count = 0
        for (var i = 0; i < str.length; i++) {
            if(str[i].indexOf('d')!==-1){
                count++
            }
        }
        console.log(count);
    </script>
~~~

~~~js
    <script>
        var str = 'dfjqwoerjowqejr'
        // 统计每一个字符出现的次数
        // 先去重
        var arr = str.split('')
        function ways(array) {
            return array.filter(function (index, item, array) {
                return array.indexOf(index) == item
            })
        }
        var newstr = ways(arr)
        console.log(newstr);
        // 去重成功
        // 将数组的值转为对象的键
        var obj = {}
        for (var y in newstr) {
                x = newstr[y]
                obj[x] = 0
        }
        console.log(obj);
        // ok 开始判断
        for(var i in str){
            for(var j in obj){
                if(str[i]==j){
                    obj[j]++
                }
            }
        }
        console.log(obj);
        // 完成
    </script>
~~~

##### 函数封装

- 完成一个求数组中最大值的函数封装

- <script>
            // 完成一个求数组中最大值的函数封装
            function arrMax (arr){
                var max = [];
                for(var i = 0;i < arr.length;i++){
                    max = Math.max(arr[i],max)
                }
                return max
            }
        </script>

- 完成求任意两个随机数的函数

- <script>
             function random_str (str,n){
                 var strString = "";
                 for(var i = 0; i < n;i++){
                     var str_random = Math.floor(Math.random()*str.length)
                     strString += str[str_random]
                 }
                 return strString
             }
         </script>

- 数组去重封装

      <script>
          function unique (arr){
              var array = []
              for(var i = 0;i < arr.length;i++){
                  array.indexOf(arr[i]) === -1 ? array.push(arr[i]):"";
              }
              return array
          }

##### 简答题

1 闭包是什么 闭包的优点和缺点是什么？

简单的讲，闭包就是在一个函数中返回另一个函数(利用作用域链 外部引用的函数 访问内部的变量)

闭包中一般存在一个自由变量，自由变量不属于函数局部变量的变量 也不是它的参数，却能被内部函数访问，这种情况我们也叫闭包，我所理解的闭包，就是执行上下文销毁，自由变量被调用且及时保存到了外部中，所以它一直没有销毁存在于内存，这就导致一个缺点，内存泄漏，通常我们使用标记清除法实现零引用或者立即执行函数解决，闭包也有很多优点，例如函数内部能访问函数外部变量，实现变量的私有化，还有防止了变量污染

2：什么是作用域 

作用域规定了执行函数对变量的访问权限 在函数执行前作用域就产生了，所以js采用的值静态作用域，作用域分为局部作用域；全局作用域；eval作用域；还有es6新增的let和conse构成的块级作用域。



3：什么是作用域链

函数执行前会产生执行上下文，执行上下中的活动变量就是作用域的值，每个函数执行前都会产生作用域链，它是一个不可访问的变量[[sope]]，当函数执行前，第一个产生全局上下文，GO就压入了作用链底部，然后函数执行，执行一个添加一个活动对象AO，所以当函数自身作用域链找不到变量的时候，会一层一层顺着作用域链往下找，直到找到GO，找不到作罢

4：如何解决闭包导致内存泄露呢?

通常我们使用标记清除法实现零引用触发垃圾回收机制或者立即执行函数解决

5: 从作用域的角度 说一下 为什么闭包中外部可以访问内部的函数变量

内部变量没有声明，肯定会去它的作用域链找，发现函数外部有，就拿过来用了

当函数执行完毕，执行上下文会销毁，但是这个函数却return出来了保留在了外部中，这就构成了闭包

6：谈一下你垃圾回收机制的认识

像闭包产生的变量一直不释放，导致内存占用过高，我们就需要使用赋值null的方式，清除变量，因为null不占用内存，是彻底删除，我们把这种方法叫垃圾回收机制

7：从内存角度谈谈你对闭包的认识

1.函数执行时会创建执行上下文，函数执行完毕 上下文栈销毁

2.上下文中变量对象存放所有函数中声明的变量

3.上下文销毁但是变量没有销毁，因为存在引用。所有导致内存泄漏

8：如何将一个类数组变为真数组？请写出 2中方法

Array from

[...array]

9：什么是递归呢？递归的弊端但是什么？

在函数中返回本函数 

10：作用域是什么时候产生的呢？

在执行上下文产生后 可执行代码执行前

11：请说出你判断thsi 指向的方法是什么呢？

在全局中 this指向window

在箭头函数中，没有this，会去上一层找

在函数中 谁触发了函数指向谁

bind apply call 触发的调用的是参数一

new触发指向实例化对象

普通对象谁调用谁触发 

12  谈谈你对原型 原型链 继承的认识

原型是function对象的一个属性 它定义了构造函数构造出的对象的公共祖先

通过该构造函数构造的对象 可以继承该原型的属性和方法

原型也有原型，所有原型的尽头都是object的原型，所以如果想查找变量或者方法，第一先去它自己的原型找，找不到会一直顺着原型找直到object的原型，再往下就是null了，我们管这种链式结构叫做原型链

js中的继承和其他语言不同，它是直接去原型链中找了

13 Function与 function的区别是什么

Function没有构造函数

function的构造函数时Function

14 什么是异步？

异步：执行慢的程序 放在异步中
异步：非阻塞代码执行，当满足执行条件后；才执行这个代码 

15：什么是回掉函数

将函数作为参数传递的函数叫回调函数

16 请说一下你是如何理解 js 是解析型语言的

js是一段一段执行的

首先会进行语法分析 看有没有语法错误

然后预编译

最后才执行

17：谈一下你对执行期上下文的认识

js引擎在遇到可执行代码前会有一个准备工作，比如，首先遇到的是全局，产生了一个全局的执行上下文，然后执行函数，又会产生局部的执行上下文，其中执行上下文中又有作用域链 活动对象 this指向

18arguements 的作用是什么？

接受实参 可以通过判断它长度来看接收了几个实参满足一些特定需求，0位是第一个实参，1位是第二个，依次类推，通常需要转换为真数组使用

19 call apply bind 的区别是什么？

首先他们三都改变指向为参数一

但是bind并不执行 需要加（）执行

apply执行了传入的数组样式的实参，函数接收的数组内的每一个值

call是规规矩矩传参

20原始类型有哪几种？null 是对象嘛？（可以理解为js数据有几种null是对象吗）

 在 JS 中，存在着 6 种原始值，分别是：
boolean
null
undefined
number
string
symbol
首先原始类型存储的都是值，是没有函数可以调用的，比如undefined.toString()
此时你肯定会有疑问，这不对呀，明明'1'.toString()是可以使用的。其实在这种情况下，'1'已经不是原始类型了，而是被强制转换成了String类型也就是对象类型，所以可以调用toString函数。除了会在必要的情况下强转类型以外，原始类型还有一些坑：其中 JS 的number类型是浮点类型的，在使用中会遇到某些 Bug，比如0.1 + 0.2 !== 0.3，但是这一块的内容会在进阶部分讲到。string类型是不可变的，无论你在string类型上调用何种方法，都不会对值有改变。另外对于null来说，很多人会认为他是个对象类型，其实这是错误的。虽然typeof null会输出object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象，然而null表示为全零，所以将它错误的判断为object。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 

21 变量的使用规则是什么？

1.在当前的作用域中查找是否有声明的该变量，如果没有去上一层作用域中去寻找，直到var声明为止

2.使用值：距离使用时最近的一次赋值，不看作用域，只看代码编写顺序

22 对象类型和原始（基本）类型的不同之处？函数参数是对象会发生什么问题？

主要是存放的地方不同

基本类型数据存放在栈中

引用数据类型放在堆中，地址放在栈中

函数参数是对象会被执行

23 typeof 与instansof判断数据的区别是什么

typeof 能判断所有，返回的字符串  array object null 都会被返回object 

instansof 后面为Object能判断是否为对象 Array能判断是否是数组

24类型转换在 JS 中类型转换只有哪三种情况？

number string boolean

25如何正确判断 this？箭头函数的 this 是什么？

在全局中 this指向window

在箭头函数中，没有this，会去上一层找

在函数中 谁触发了函数指向谁

bind apply call 触发的调用的是参数一

new触发指向实例化对象

普通对象谁调用谁触发 

26== 和 === 有什么区别？

== 判断值或隐式转换的值是否相等

===判断值和类型是否全等

27：javascript中的数据类型有哪些？

基本数据类型 string null boolean number number

引用数据类型 数组 对象 函数

28：Javascript中所支持的数字函数

 E	返回算术常量 e，即自然对数的底数（约等于2.718）。
LN2	返回 2 的自然对数（约等于0.693）。
LN10	返回 10 的自然对数（约等于2.302）。
LOG2E	返回以 2 为底的 e 的对数（约等于 1.414）。
LOG10E	返回以 10 为底的 e 的对数（约等于0.434）。
PI	返回圆周率（约等于3.14159）。
SQRT1_2	返回返回 2 的平方根的倒数（约等于 0.707）。
SQRT2	返回 2 的平方根（约等于 1.414）。 

...

29 二进制浮点数和四舍五入错误

 js采用IEEE-754浮点数表示法（几乎所有现代编程语言采用），这是一种二进制表示法，可以精确的表示分数如 1/2、1/4、1/8和1/1024。但遗憾的是我们经常用的分数（特别是金融方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示累0.1这简单的数字。

js中的数字具有足够的精度，并可以即期近似于0.1。但数字不能精确表述的确带来一些问题。如

var x = 0.3-0.2

var y = 0.2-0.1

x == y  //false两值不相等

由于舍入误差。0.3-0.2的近似差值使劲上并不等于02.-0.1的近视差。但x和y的值非常接近彼此和最终的正确值。 

30字符串常用的方法写出5个

split 切割转数组

substr 截取片段 第二位是长度

substring 截取片段

slice 截取片段

match() 匹配元素

charAt：返回查找的元素下标

31如何比较两个数组是否相等？

变成字符串比较是否全等

32运算符的优先级

 括号成员最高级 全体单目排第二 乘除余三 加减四 移位五 关系六 等于不等于排老七 逻辑八 赋值九 逗号成员排最低 

##### 按照要求写一下表达式

~~~js
// 如何x 不是一个数组
if(Array.isarray(x))

// 如何判断一个x可能是数组 可能是对象
if(x instanceof Object)

// 如何判断一个x 一定是对象
if(x.constructor==Object)

// 如何做 x 的去反操操作
!x
// 如何让一个数组转化为字符串后 可能看到数组中的每个元素
arr.split('')
for(var x in arr){
    console.log(arr[x])
}

// 如何判断两个数组 完全相等
    var arr1 = [1,2,3]
    var arr2 = [1,2,3]
    var arr3 = arr1.toString()
    var arr4 = arr2.toString()
    console.log(arr3 === arr4);
~~~



##### 写一下运算过程

~~~
var res =(1>2)||(true>false)&&(!0);
1>2 false
(true>false) true
(!0) true
false||true && true
true && true
true
~~~





##### 请写出下列程序的输出结果

~~~js
      var obj1 = {
        a: 1,
        say: function() {
          console.log([...arguments], "obj1");
            // array[1, 2, 3, 4] "obj1"
     
          console.log(this);
            // obj2
         
          console.log(this.a);
            // 2
        
        }
      };
      var obj2 = {
        a: 2,
        say: function(a, b, c) {
          console.log([...arguments], "obj2");
                   // array[1, 2, 3, 4, 5] 'obj2'
          console.log(this);
               // obj1
          console.log(this.a);
                // 1
        }
      };

      obj1.say.call(obj2, 1, 2, 3, 4);
		// call触发 obj2指向 传入1，2，3，4参数
      obj2.say.apply(obj1, [1, 2, 3, 4, 5]);
		// apply触发 obj1指向 传入1，2，3，4，5


~~~

~~~js
var add = (function () {
    var counter = 0;
    return function () {
        return counter += 1;
    }
})();
add(); // 闭包问题 执行了三次 每次加1 答案是3
add();
alert(add())
~~~

~~~js
  function foo() {
        var a = 1;
        return function() {
          console.log(++a); 
        };
      }
 var res = foo()
 res()
// 闭包问题 执行了两次 每次加1 答案是2
~~~



### dom



1:dom 的选择器有哪些？3个

getElementById id选择器

getElementsByClassName class 选择器

querySelectorAll 选择器最常用



2：dom的选择器的作用是什么

绑定元素，方便dom操作样式

3：如何判断对象是否为dom 对象

nodeType进行判断

4：dom 关系节点有哪些；如何获取

previousElementSibling 查看兄弟节点（上一个）

nextSibling  查看兄弟节点（下一个）

childen 获取子节点

parentNode 获取父节点



5：dom的增删改克隆 如何实现 

dom.createElement增加 

dom.remove删除

dom.repalce(new,old)

dom.cloneNode()

```